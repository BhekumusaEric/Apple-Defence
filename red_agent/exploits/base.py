"""
Base Exploit Module

This module defines the base class for all exploits used by the Red Agent.
"""

import logging
from typing import Dict, Any, Optional
import uuid
import time

logger = logging.getLogger(__name__)

class ExploitBase:
    """
    Base class for all exploits.
    
    All specific exploit implementations should inherit from this class
    and implement the required methods.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the exploit with configuration parameters.
        
        Args:
            config: Configuration dictionary for the exploit
        """
        self.config = config or {}
        self.id = str(uuid.uuid4())
        self.name = self.__class__.__name__
        self.description = "Base exploit class"
        self.target_ios_versions = []
        self.target_devices = []
        self.cve_ids = []
        self.success_rate = 0.0
        self.last_execution = None
        self.execution_count = 0
        self.successful_executions = 0
        
        logger.debug("Initialized exploit: %s", self.name)
    
    def is_applicable(self, vulnerability: Dict[str, Any]) -> bool:
        """
        Determine if this exploit is applicable to the given vulnerability.
        
        Args:
            vulnerability: Information about the vulnerability
            
        Returns:
            True if the exploit is applicable, False otherwise
        """
        # Base implementation - subclasses should override with specific logic
        return False
    
    def execute(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the exploit against the given vulnerability.
        
        Args:
            vulnerability: Information about the vulnerability
            
        Returns:
            Result of the exploitation attempt
        """
        self.execution_count += 1
        self.last_execution = time.time()
        
        # Base implementation - subclasses should override with specific logic
        result = {
            "exploit_id": self.id,
            "exploit_name": self.name,
            "vulnerability_id": vulnerability.get("id"),
            "timestamp": self.last_execution,
            "success": False,
            "message": "Base exploit does not implement execution logic"
        }
        
        logger.warning("Attempted to execute base exploit class: %s", self.name)
        
        return result
    
    def cleanup(self) -> None:
        """
        Clean up after exploit execution.
        
        This method should be called after execute() to ensure any resources
        are properly released and the system is returned to a clean state.
        """
        # Base implementation - subclasses should override with specific logic
        logger.debug("Cleanup called for exploit: %s", self.name)
    
    def get_metadata(self) -> Dict[str, Any]:
        """
        Get metadata about this exploit.
        
        Returns:
            Dictionary containing exploit metadata
        """
        success_rate = 0.0
        if self.execution_count > 0:
            success_rate = self.successful_executions / self.execution_count * 100.0
            
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "target_ios_versions": self.target_ios_versions,
            "target_devices": self.target_devices,
            "cve_ids": self.cve_ids,
            "execution_count": self.execution_count,
            "successful_executions": self.successful_executions,
            "success_rate": success_rate,
            "last_execution": self.last_execution
        }
